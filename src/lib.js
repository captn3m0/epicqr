// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["eci"] = $hx_exports["eci"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var haxe_crypto_Aes = function(key,iv) {
	haxe_crypto_Aes.initTable();
	if(key != null) {
		this.init(key,iv);
	}
};
haxe_crypto_Aes.__name__ = true;
haxe_crypto_Aes.initTable = function() {
	haxe_crypto_Aes.SBOX = new Array(256);
	haxe_crypto_Aes.RSBOX = new Array(256);
	haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_0 = new Array(256);
	haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_1 = new Array(256);
	haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_2 = new Array(256);
	haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_3 = new Array(256);
	haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_0 = new Array(256);
	haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_1 = new Array(256);
	haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_2 = new Array(256);
	haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_3 = new Array(256);
	haxe_crypto_Aes.RCON = new Array(11);
	var d = new Array(256);
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		if(i < 128) {
			d[i] = i << 1;
		} else {
			d[i] = i << 1 ^ 283;
		}
	}
	var x = 0;
	var xi = 0;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
		sx = sx >>> 8 ^ sx & 255 ^ 99;
		haxe_crypto_Aes.SBOX[x] = sx;
		haxe_crypto_Aes.RSBOX[sx] = x;
		var x2 = d[x];
		var x4 = d[x2];
		var x8 = d[x4];
		var t = d[sx] * 257 ^ sx * 16843008;
		haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_0[x] = t << 24 | t >>> 8;
		haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_1[x] = t << 16 | t >>> 16;
		haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_2[x] = t << 8 | t >>> 24;
		haxe_crypto_Aes.SUB_BYTES_MIX_COLUMN_3[x] = t;
		t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
		haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_0[sx] = t << 24 | t >>> 8;
		haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_1[sx] = t << 16 | t >>> 16;
		haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_2[sx] = t << 8 | t >>> 24;
		haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_3[sx] = t;
		if(x == 0) {
			xi = 1;
			x = xi;
		} else {
			x = x2 ^ d[d[d[x8 ^ x2]]];
			xi ^= d[d[xi]];
		}
	}
	haxe_crypto_Aes.RCON[0] = 0;
	haxe_crypto_Aes.RCON[1] = 1;
	haxe_crypto_Aes.RCON[2] = 2;
	haxe_crypto_Aes.RCON[3] = 4;
	haxe_crypto_Aes.RCON[4] = 8;
	haxe_crypto_Aes.RCON[5] = 16;
	haxe_crypto_Aes.RCON[6] = 32;
	haxe_crypto_Aes.RCON[7] = 64;
	haxe_crypto_Aes.RCON[8] = 128;
	haxe_crypto_Aes.RCON[9] = 27;
	haxe_crypto_Aes.RCON[10] = 54;
};
haxe_crypto_Aes.prototype = {
	set_iv: function(vector) {
		this.iv = vector;
		if(this.iv == null) {
			this.iv = new haxe_io_Bytes(new ArrayBuffer(16));
			this.iv.fill(0,16,0);
		}
		return this.iv;
	}
	,init: function(key,iv) {
		this.Nk = key.length >> 2;
		this.Nr = this.Nk + 6;
		this.keyRows = (this.Nr + 1) * 4;
		this.state = new Array(this.Nk);
		this.set_iv(iv);
		this.keyExpansion(key);
	}
	,keyExpansion: function(key) {
		this.roundKey = new Array(this.keyRows);
		var _g = 0;
		var _g1 = this.keyRows;
		while(_g < _g1) {
			var ksRow = _g++;
			if(ksRow < this.Nk) {
				this.roundKey[ksRow] = this.bytesToInt32(key,ksRow << 2);
			} else {
				var t = this.roundKey[ksRow - 1];
				if(ksRow % this.Nk == 0) {
					t = t << 8 | t >>> 24;
					t = haxe_crypto_Aes.SBOX[t >>> 24] << 24 | haxe_crypto_Aes.SBOX[t >>> 16 & 255] << 16 | haxe_crypto_Aes.SBOX[t >>> 8 & 255] << 8 | haxe_crypto_Aes.SBOX[t & 255];
					t ^= haxe_crypto_Aes.RCON[Math.floor(ksRow / this.Nk) | 0] << 24;
				} else if(this.Nk > 6 && ksRow % this.Nk == 4) {
					t = haxe_crypto_Aes.SBOX[t >>> 24] << 24 | haxe_crypto_Aes.SBOX[t >>> 16 & 255] << 16 | haxe_crypto_Aes.SBOX[t >>> 8 & 255] << 8 | haxe_crypto_Aes.SBOX[t & 255];
				}
				this.roundKey[ksRow] = this.roundKey[ksRow - this.Nk] ^ t;
			}
		}
		this.rRoundKey = new Array(this.keyRows);
		var keyRow;
		var t;
		var _g = 0;
		var _g1 = this.keyRows;
		while(_g < _g1) {
			var i = _g++;
			keyRow = this.keyRows - i;
			if(i % 4 != 0) {
				t = this.roundKey[keyRow];
			} else {
				t = this.roundKey[keyRow - 4];
			}
			if(i < 4 || keyRow <= 4) {
				this.rRoundKey[i] = t;
			} else {
				this.rRoundKey[i] = haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_0[haxe_crypto_Aes.SBOX[t >>> 24]] ^ haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_1[haxe_crypto_Aes.SBOX[t >>> 16 & 255]] ^ haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_2[haxe_crypto_Aes.SBOX[t >>> 8 & 255]] ^ haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_3[haxe_crypto_Aes.SBOX[t & 255]];
			}
		}
	}
	,decryptBlock: function(src,srcIndex,dst,dstIndex) {
		if(dstIndex == null) {
			dstIndex = 0;
		}
		this.state[0] = this.bytesToInt32(src,srcIndex);
		this.state[1] = this.bytesToInt32(src,srcIndex + 4);
		this.state[2] = this.bytesToInt32(src,srcIndex + 8);
		this.state[3] = this.bytesToInt32(src,srcIndex + 12);
		var t = this.state[1];
		this.state[1] = this.state[3];
		this.state[3] = t;
		this.generateBlock(this.rRoundKey,haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_0,haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_1,haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_2,haxe_crypto_Aes.RSUB_BYTES_MIX_COLUMN_3,haxe_crypto_Aes.RSBOX);
		t = this.state[1];
		this.state[1] = this.state[3];
		this.state[3] = t;
		this.int32ToBytes(this.state[0],dst,dstIndex);
		this.int32ToBytes(this.state[1],dst,dstIndex + 4);
		this.int32ToBytes(this.state[2],dst,dstIndex + 8);
		this.int32ToBytes(this.state[3],dst,dstIndex + 12);
	}
	,generateBlock: function(keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX) {
		var state0 = this.state[0] ^ keySchedule[0];
		var state1 = this.state[1] ^ keySchedule[1];
		var state2 = this.state[2] ^ keySchedule[2];
		var state3 = this.state[3] ^ keySchedule[3];
		var ksRow = 4;
		var tmp0;
		var tmp1;
		var tmp2;
		var tmp3;
		var _g = 1;
		var _g1 = this.Nr;
		while(_g < _g1) {
			var round = _g++;
			tmp0 = SUB_MIX_0[state0 >>> 24] ^ SUB_MIX_1[state1 >>> 16 & 255] ^ SUB_MIX_2[state2 >>> 8 & 255] ^ SUB_MIX_3[state3 & 255] ^ keySchedule[ksRow++];
			tmp1 = SUB_MIX_0[state1 >>> 24] ^ SUB_MIX_1[state2 >>> 16 & 255] ^ SUB_MIX_2[state3 >>> 8 & 255] ^ SUB_MIX_3[state0 & 255] ^ keySchedule[ksRow++];
			tmp2 = SUB_MIX_0[state2 >>> 24] ^ SUB_MIX_1[state3 >>> 16 & 255] ^ SUB_MIX_2[state0 >>> 8 & 255] ^ SUB_MIX_3[state1 & 255] ^ keySchedule[ksRow++];
			tmp3 = SUB_MIX_0[state3 >>> 24] ^ SUB_MIX_1[state0 >>> 16 & 255] ^ SUB_MIX_2[state1 >>> 8 & 255] ^ SUB_MIX_3[state2 & 255] ^ keySchedule[ksRow++];
			state0 = tmp0;
			state1 = tmp1;
			state2 = tmp2;
			state3 = tmp3;
		}
		tmp0 = (SBOX[state0 >>> 24] << 24 | SBOX[state1 >>> 16 & 255] << 16 | SBOX[state2 >>> 8 & 255] << 8 | SBOX[state3 & 255]) ^ keySchedule[ksRow++];
		tmp1 = (SBOX[state1 >>> 24] << 24 | SBOX[state2 >>> 16 & 255] << 16 | SBOX[state3 >>> 8 & 255] << 8 | SBOX[state0 & 255]) ^ keySchedule[ksRow++];
		tmp2 = (SBOX[state2 >>> 24] << 24 | SBOX[state3 >>> 16 & 255] << 16 | SBOX[state0 >>> 8 & 255] << 8 | SBOX[state1 & 255]) ^ keySchedule[ksRow++];
		tmp3 = (SBOX[state3 >>> 24] << 24 | SBOX[state0 >>> 16 & 255] << 16 | SBOX[state1 >>> 8 & 255] << 8 | SBOX[state2 & 255]) ^ keySchedule[ksRow++];
		this.state[0] = tmp0;
		this.state[1] = tmp1;
		this.state[2] = tmp2;
		this.state[3] = tmp3;
	}
	,bytesToInt32: function(bs,off) {
		var n = (bs.b[off] & 255) << 24;
		n |= (bs.b[++off] & 255) << 16;
		n |= (bs.b[++off] & 255) << 8;
		n |= bs.b[++off] & 255;
		return n;
	}
	,int32ToBytes: function(n,bs,off) {
		bs.b[off] = n >> 24;
		bs.b[++off] = n >> 16;
		bs.b[++off] = n >> 8;
		bs.b[++off] = n;
	}
};
var eci_Crypto = function(key,iv) {
	haxe_crypto_Aes.call(this,key,iv);
};
eci_Crypto.__name__ = true;
eci_Crypto.__super__ = haxe_crypto_Aes;
eci_Crypto.prototype = $extend(haxe_crypto_Aes.prototype,{
	decrypt: function(cipherMode,data,padding) {
		if(padding == null) {
			padding = "PKCS7";
		}
		var out = data.sub(0,data.length);
		haxe_crypto_mode_CBC.decrypt(out,this.iv,16,$bind(this,this.decryptBlock));
		return haxe_crypto_padding_PKCS7.unpad(out);
	}
});
var eci_EpicQR = $hx_exports["eci"]["EpicQR"] = function() { };
eci_EpicQR.__name__ = true;
eci_EpicQR.decode = function(input) {
	var cipherText = haxe_crypto_Base64.decode(input);
	var c = new eci_Crypto();
	var key = haxe_io_Bytes.ofString("X_4k$uq23FSwI.qT");
	var iv = haxe_io_Bytes.ofString("H76$suq23_po(8sD");
	c.init(key,iv);
	var jsonString = c.decrypt("cbc",cipherText).toString();
	var _d = JSON.parse(jsonString);
	return new eci_Result(_d.epic_no,_d.unique_generated_id);
};
var eci_Result = function(epic,id) {
	this.epic = epic;
	this.id = id;
};
eci_Result.__name__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_crypto_mode_CBC = function() { };
haxe_crypto_mode_CBC.__name__ = true;
haxe_crypto_mode_CBC.decrypt = function(src,iv,blockSize,decryptBlock) {
	var vpos = src.length - blockSize;
	var i = src.length;
	while(i > 0) {
		i -= blockSize;
		vpos -= blockSize;
		decryptBlock(src,i,src,i);
		if(vpos < 0) {
			var _g = 0;
			var _g1 = blockSize;
			while(_g < _g1) {
				var j = _g++;
				src.b[j] ^= iv.b[j];
			}
		} else {
			var _g2 = 0;
			var _g3 = blockSize;
			while(_g2 < _g3) {
				var j1 = _g2++;
				src.b[i + j1] ^= src.b[vpos + j1];
			}
		}
	}
};
var haxe_crypto_padding_PKCS7 = function() { };
haxe_crypto_padding_PKCS7.__name__ = true;
haxe_crypto_padding_PKCS7.unpad = function(encrypt) {
	var padding = encrypt.b[encrypt.length - 1];
	if(padding > encrypt.length) {
		throw haxe_Exception.thrown("Cannot remove " + padding + " bytes, because message is " + encrypt.length + " bytes");
	}
	var block = encrypt.length - padding;
	var _g = block;
	var _g1 = encrypt.length;
	while(_g < _g1) {
		var i = _g++;
		if(encrypt.b[i] != padding) {
			throw haxe_Exception.thrown("Invalid padding value. Got " + encrypt.b[i] + ", expected " + padding + " at position " + i);
		}
	}
	return encrypt.sub(0,block);
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
eci_EpicQR.IV = "H76$suq23_po(8sD";
eci_EpicQR.KEY = "X_4k$uq23FSwI.qT";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
